
 디자인패턴_얄코



 # 객체지향 디자인패턴 1.

Singleton.
프로세스 내에서 딱 하나의 오브젝트만 존재해야 되는 경우 사용한다.
객체를 static private으로 만들고, 생성자를 private으로 만든다.
getInstance( )를 통해 객체를 하나만 생성하게 만든다. ( 방법은 여러가지 )
interface, lazy loading에서 활용할 수 있다. ( 더 공부하기 )

Strategy 패턴 - 전략 패턴.
어떠한 상황( 이벤트 )에 따라 실행되는 동작이 다르게 작성하는 것.
인터페이스를 만들고 상황에 따라 다른 구현객체를 DI해서 다른 동작을 실행한다.

State 패턴.
Strategy와 거의 흡사하다.
State는 TV를 껏다 켰다와 같이 상태에 따라 동작을 다르게 실행하는 것을 말한다.

Command 패턴.
Strategy와 거의 흡사하다.
Strategy는 하는 일은 같으나 알고리즘이 다른데, Command는 하는 일 자체가 다르다.
Strategy보다 좀 더 다양한 방식으로 구성할 수 있다.
여러 작업을 수행해서 한번에 실행시키는 로직 등에 활용할 수 있다.

Adapter 패턴.
인터페이스가 서로 다른 클래스들이 같은 형식에서 작동할 수 있도록 도와준다.
실행 메소드의 이름이 서로 다른 A, B클래스를 Adapter를 통해 run( )이라는 메소드이름으로 통일시켜 동작.
A, B클래스에 Adapter 클래스를 생성하여 run( )을 호출하면 A, B 클래스에 실행 메소드를 호출.

Proxy 패턴.
중요하지 않은 작은 작업들을 대리 클래스로 처리하고, 중요한 작업들은 진짜 클래스로 처리한다.



 # 객체지향 디자인패턴 2.

Facade 패턴.
여러가지 클래스, 메소드를 반복해서 사용해야 될 경우 하나의 메소드로 묶어서 사용.

Template-method 패턴.
같은 형식을 지닌 특정 작업들의 세부 방식을 다양화할 때 사용.
A-B-C형식이 있을 때 A-B-C형식을 인터페이스로 만들고, 구현 객체를 다양화한다.
공통된 절차가 있을 때 사용.

Decorator 패턴.
특정 클래스의 객체들이 할 수 있는 일을 여러가지 두고 객체마다 골라쓰는 방법.

Factory-method 패턴.
Factory 클래스를 통해 객체를 생성한다.
생성자가 바뀌었을 때 수정이 편리하다와 생성자를 정확히 알지 못해도 사용할 수 있다는 장점을 가진다.

Abstract-factory 패턴.
Factory 인터페이스를 하나 만들고 구현 Factory를 여러개를 만들어서 객체를 다양하게 생성한다.

Mediatory 패턴.
클래스의 객체에서 특정 이벤트가 발생할 때마다 연결된 클래스에 알리는 역할을 하는 중재 클래스를 만든다.
인터페이스를 생성하고 연결 클래스를 구현 클래스로 만든 후 
중재 클래스에 ArrayList<인터페이스>로 연결 클래스를 추가하여 이벤트 발생시 연결 클래스에 알린다.

Composite 패턴.
폴더안에 폴더와 파일을 저장하듯이 인터페이스를 통해 삭제와 저장 등을 통해 계층 구조를 만든다.





